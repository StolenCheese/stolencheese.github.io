<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="All of my hobby projects up until 2022 in one big bundle." name=description><title>Maxwell's Website</title><link href=/monokai.css rel=stylesheet><body><nav class=top-bar><a href=https://pettett.github.io/>Home</a> / <a href=https://pettett.github.io/projects/>List of my Projects</a> / Armere</nav><div class=container><h1 class=title>Armere</h1><div class=metadata><code>
	{"date" : 2020-05-21, "tags" : ["<a href=https://pettett.github.io/tags/games/>games</a>","<a href=https://pettett.github.io/tags/cs/>cs</a>",], "repo":"<a href=https://github.com/pettett/Armere>...</a>"}
</code></div><article><p>All of my hobby projects up until 2022 in one big bundle. <span id=continue-reading></span> This was my main introduction to large codebases, to this day I think it went pretty well all things considered, and it certainly taught me a huge amount about organisation, making code that I can actually read, got me to start using vscode, and how to use git (or at least the github desktop app).<p>Communications between different projects (mechanics) are structured through event driven dependency injection, using Unity’s scriptable objects acting as event delegates (Mechanics/ScriptableObjects/EventChannels). Examples of these are connecting the enemy death event to spawning interact-able items, or connecting the player’s sword swing to destroying blades of grass.<p><img alt=Waterfall src=/projects/armere/waterfall.png><h2 id=grass>Grass</h2><p><img alt=Grass src=/projects/armere/grass.png><p>This grass I remember absolutely killing me when I first made it. Inspired in no small part by a certain open world switch game. Before the explanation, have some progress images:<div class=gallery><div class=gallery-slider><img alt="First working indirect render" onclick="var img = getElementById('gallery-1'); img.src = '/projects/armere/grass-0.png'; img.alt=alt; var t=getElementById('text-1'); t.innerText=alt" height=128 src=https://pettett.github.io/processed_images/e298d127f1d15cb200.png width=128><img alt="First working lit shader (with shadows)" onclick="var img = getElementById('gallery-1'); img.src = '/projects/armere/grass-1.png'; img.alt=alt; var t=getElementById('text-1'); t.innerText=alt" height=128 src=https://pettett.github.io/processed_images/ec5bfc3d9e28a10e00.png width=128><img alt="Density based distribution" onclick="var img = getElementById('gallery-1'); img.src = '/projects/armere/grass-2.png'; img.alt=alt; var t=getElementById('text-1'); t.innerText=alt" height=128 src=https://pettett.github.io/processed_images/e658d2a60d894ab200.png width=128><img alt="Player interaction" onclick="var img = getElementById('gallery-1'); img.src = '/projects/armere/grass-3.png'; img.alt=alt; var t=getElementById('text-1'); t.innerText=alt" height=128 src=https://pettett.github.io/processed_images/16b6fcc751dc3ddf00.png width=128></div><div class=gallery-frame><figure><img alt="First working indirect render" id=gallery-1 src=/projects/armere/grass-0.png><figcaption id=text-1>First working indirect render</figcaption></figure></div></div><p>Using draw instanced indirect functionality, I have been able to (after many attempts) create a system to place blades of grass on height mapped terrain, using local terrain data such as splatmaps to inform how the grass should be created.<p><img alt="Grass Chunking system" src=/projects/armere/grass_chunks.png><p>A chunk system is used stored as a quad-tree to enable quick loading and unloading of grass blades, represented as blocks of GPU memory.<p>Grass blades can also be destroyed using compute shaders, for example the destroy grass in bounds event channel will mark every blade of grass in the bounds as dead, then while rendering, a prefix parallel sum pass is performed to pack all living blades into a separate buffer for rendering.<h2 id=volumetrics>Volumetrics</h2><p><img alt=Volumetrics src=/projects/armere/volumetric.jpg><p>A post processing effect for the URP pipeline, added to the pipeline as a ‘Render Feature’.<p>The effect created world space volumetric lighting for beams cast from the main directional light in the scene, based on a low resolution ray march through the scene depth map and the sun’s shadow map to measure total transmission to the camera, although it was not physically based.<h2 id=cel-shading>Cel Shading</h2><p><img alt="Cel Shader" src=/projects/armere/cel.png><p>Similar inspiration to the grass, a cel shader for NPCs and the player character. A mostly standard Blinn–Phong shader with the addition of toon like ramping and a rim highlighting fresnel, with support for many engine features such as cubemapped reflections (also rendered into cel) and ambient occlusion.<h2 id=gameplay>Gameplay</h2><p>The <code>playercontroller</code> system is state driven and has a lot of functionality, including running Yarn dialogue during any “interactions” triggered, and full movement including swimming and climbing (on specific vine walls) The player is attached to it’s inventory and quest book for item and goal usage.<p>The NPCs follow routines based on the time of day, and each store there own inventory locally, allowing for any NPC to engage in trade if the dialogue command is triggered.<p>The save load system and game constructor are used to save game state directly into binary, although eventually this will use the messagepack format.<p>Enemies and Animals use a similar state based system as the <code>playercontroller</code> to perform (at the moment very basic) activities.<h2 id=physics>Physics</h2><h3 id=buoyancy>Buoyancy</h3><p><img alt="Buoyant cylinder" src=/projects/armere/log_in_water.png><p>The buoyancy system uses the voxel approach to sample discrete cubes within a physics object for how much water they displace and so how much force and torque should be enacted on the object. This is done in parallel, also using Unity Burst allowing for very fast execution.<h3 id=trees>Trees</h3><p><img alt="Tree chop" src=/projects/armere/tree_chop.png><p>Chopping down trees creates dynamic tree meshes as the trunks have cuts marked into them and are eventually felled.<p>Chops reveal the rings inside the tree by using a separate texture and material for tris created inside the trunk. This is also done in parallel using burst resulting in very quick performance.<h2 id=water>Water</h2><p>Swimming in water creates a particle effect that leaves ripples behind the player. Any items entering or exiting water create their own splashes and ripples.<p><img alt="Water Trail" src=/projects/armere/water_trail.png></article></div><footer class=footer><h2><a href=https://github.com/pettett>Github</a> | <a href=https://www.linkedin.com/in/maxwell-pettett/>LinkedIn</a> | maxwell pettett at gmail dot com | <a href=https://mastodon.gamedev.place/@pettett rel=me>Mastodon</a></h2></footer>