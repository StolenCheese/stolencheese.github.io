<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><meta content="<p>A Factorio mod I made over the christmas holiday, currently sitting at over 25K downloads (!!).</p>
" name=description><title>Maxwell's Website</title><link href=/fact.css rel=stylesheet><body><nav class=top-bar><a href=https://pettett.github.io/>Home</a> / <a href=https://pettett.github.io/projects/>List of my Projects</a> / Factorio Mod: Concentrated Solar Power</nav><div class=container><h1 class=title>Factorio Mod: Concentrated Solar Power</h1><div class=metadata><code>
	{"date" : 2022-12-13, "tags" : ["<a href=https://pettett.github.io/tags/games/>games</a>","<a href=https://pettett.github.io/tags/lua/>lua</a>","<a href=https://pettett.github.io/tags/blender/>blender</a>",], "repo":"<a href=https://github.com/pettett/ch-concentrated-solar>...</a>", "site":"<a href=https://mods.factorio.com/mod/ch-concentrated-solar>...</a>"}
</code></div><article><p>A Factorio mod I made over the christmas holiday, currently sitting at over 25K downloads (!!).</p><span id=continue-reading></span><img alt="Mod Opengraph Information Embed" height=200px src=https://mods.factorio.com/opengraph/mod/ch-concentrated-solar.png><p>I’m quite happy with the power output as it stands at the default though, it was always intended as an improvement to solar rather then a nuclear power competitor, and if it were to take up the exact space as nuclear while still being about to work 24/7, as well as how energy dense steam storage can be, I think it would quickly become very unbalanced (see the other existing concentrated solar mod).<p>The reason solar intensity was set at 600 however was to limit the range on heat pipes, to incentivise close heat exchangers pumping steam to turbines further away, as a bit of a spacing puzzle.</p><img class=banner src=/projects/banner2.png><h2 id=inner-workings-experience-with-the-mod-api>Inner Workings + Experience with the Mod API</h2><h3 id=main-functions>Main Functions</h3><p>Every modded item in Factorio has to be derived from an existing “prototype”, a definition of an entity with a set of parameters set when the game loads, and with a special purpose in the game processing loop; a <code>light</code> prototype has some light property that determines how it will illuminate the world, for example.<p>Towers use the <code>reactor</code> prototype definition, as the only one in the game to generate heat from a power source. The contents/burning fuel of the reactor is a custom fluid named <code>solar-intensity</code>, the the amount of power generated scaling based on its temperature, allowing the power of a tower to be scaled easily by the number of surrounding mirrors, just by setting their temperature. The main downside of this is that in Factorio 0°≠ empty, despite both producing no power, so the tower’s fluid box must be explicitly drained during night/with no surrounding mirrors to display the no fuel icon.<p id=coremain>The main loop of the mod is then as such:<pre class=language-lua data-lang=lua style=background-color:#272822;color:#f8f8f2;><code class=language-lua data-lang=lua><span style=color:#f92672;>local </span><span style=font-style:italic;color:#66d9ef;>function </span><span style=color:#a6e22e;>on_nth_tick_tower_update</span><span>(</span><span style=font-style:italic;color:#fd971f;>event</span><span>)
</span><span>
</span><span>	</span><span style=color:#75715e;>-- Place fluid in towers
</span><span>
</span><span>	</span><span style=color:#f92672;>if not </span><span>global.tower_mirrors[global.last_updated_tower] </span><span style=color:#f92672;>then
</span><span>		global.last_updated_tower </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>nil
</span><span>	</span><span style=color:#f92672;>end
</span><span>    </span><span style=color:#75715e;>-- Update towers incrementally, to spread cost of computation across many frames
</span><span>	</span><span style=color:#f92672;>for </span><span>i </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>1</span><span>, global.tower_update_count </span><span style=color:#f92672;>or </span><span style=color:#ae81ff;>1</span><span>, </span><span style=color:#ae81ff;>1 </span><span style=color:#f92672;>do
</span><span>
</span><span>		global.last_updated_tower </span><span style=color:#f92672;>= </span><span style=color:#66d9ef;>next</span><span>(global.tower_mirrors, global.last_updated_tower)
</span><span>
</span><span>		</span><span style=color:#f92672;>if </span><span>global.last_updated_tower </span><span style=color:#f92672;>then
</span><span>			</span><span style=color:#f92672;>local </span><span>tid </span><span style=color:#f92672;>= </span><span>global.last_updated_tower
</span><span>			</span><span style=color:#f92672;>local </span><span>mirrors </span><span style=color:#f92672;>= </span><span>global.tower_mirrors[tid]
</span><span>
</span><span>			</span><span style=color:#75715e;>-- Attempt to update tower {tid} (it may no longer exist)
</span><span>
</span><span>			</span><span style=color:#f92672;>local </span><span>tower </span><span style=color:#f92672;>= </span><span>global.towers[tid]
</span><span>
</span><span>			</span><span style=color:#f92672;>if </span><span>tower </span><span style=color:#f92672;>and </span><span>tower.valid </span><span style=color:#f92672;>then 
</span><span>                </span><span style=color:#75715e;>-- Get the amount of sun currently on a 0-1 scale
</span><span>                </span><span style=color:#75715e;>-- identical to how solar panels calculate it
</span><span>				</span><span style=color:#f92672;>local </span><span>sun </span><span style=color:#f92672;>= </span><span>control_util.calc_sun(tower.surface)
</span><span>
</span><span>				tower.clear_fluid_inside()
</span><span>
</span><span>				</span><span style=color:#f92672;>if </span><span>sun </span><span style=color:#f92672;>> </span><span style=color:#ae81ff;>0 </span><span style=color:#f92672;>and </span><span>table_size(mirrors) </span><span style=color:#f92672;>> </span><span style=color:#ae81ff;>0 </span><span style=color:#f92672;>then
</span><span>					</span><span style=color:#f92672;>local </span><span>amount </span><span style=color:#f92672;>= </span><span>control_util.fluidTempPerMirror </span><span style=color:#f92672;>* </span><span>sun </span><span style=color:#f92672;>* </span><span>table_size(mirrors)
</span><span>					</span><span style=color:#75715e;>-- set to temperature and amount, as fluid turrets cannot display temperature
</span><span>					tower.insert_fluid {
</span><span>						</span><span style=color:#e6db74;>name        </span><span>= control_util.mod_prefix </span><span style=color:#f92672;>.. </span><span style=color:#e6db74;>"solar-fluid"</span><span>,
</span><span>						</span><span style=color:#e6db74;>amount      </span><span>= amount,
</span><span>						</span><span style=color:#e6db74;>temperature </span><span>= amount
</span><span>					}
</span><span>				</span><span style=color:#f92672;>end
</span><span>			</span><span style=color:#f92672;>else
</span><span>				control_util.notify_tower_invalid(tid)
</span><span>			</span><span style=color:#f92672;>end
</span><span>		</span><span style=color:#f92672;>end
</span><span>	</span><span style=color:#f92672;>end
</span><span style=color:#f92672;>end
</span></code></pre><p>Key to this is maintaining the table <code>global.tower_mirrors</code>, which is a map between tower ids <code>tid</code> and an array of mirror entities, which proved to be very annoying. But doable, eventually.<p>First task was tracking down which events were called when creating and destroying entities, which turned out to be, for destroying:<ul><li><code>defines.events.on_pre_player_mined_item</code><li><code>defines.events.on_robot_pre_mined</code><li><code>defines.events.on_entity_died</code><li><code>defines.events.script_raised_destroy</code></ul><p>And for creating:<ul><li><code>defines.events.on_built_entity</code><li><code>defines.events.on_robot_built_entity</code><li><code>defines.events.script_raised_built</code> (event carries <code>entity</code> instead of <code>created_entity</code>)<li><code>defines.events.script_raised_revive</code> (same as above)</ul><p>When placing a tower or a mirror, we ask the game for every prototype in a <code>radius</code> square around them, and perform the relevant linkings.<p>Mirrors are simple; if there are no towers in range, do nothing, one tower in range, link to it, or multiple towers in range, link to the closest and store the others in range locally.<p>Towers are a little more complex, but effectively obey the same rules for linking as mirrors, just from the other direction, and with enough trial and error this was working too.<p>The complexities start to arise when destroying entities. Mirrors simply remove themselves from their tower’s link, but removing a tower requires going through every mirror, removing itself as it’s closest, and linking it to the mirror’s next closest tower (which is why we store other towers in range during creation- without this, destroying a tower created a large lag spike as each mirror searched from scratch for towers in range).<h3 id=mirror-rotations>Mirror Rotations</h3><p>Mirrors are overrides of the <code>turret</code> prototype, with 0 range and no military presence, due to the fact that these prototypes are one of the very few in the game with support for rotationally-determined graphics<sup class=footnote-reference><a href=#rot>1</a></sup>. From testing, despite the in theory more complex entity types, they did not contribute noticeably to the tick time, and I can only assume the engine identifies these ‘turrets’ as useless and excludes them from the weapon loop. Hopefully one day a generic rotatable entity base is added so this need not be a concern.<h3 id=beams>Beams</h3><figure><img alt=Beams src=/projects/ch-concentrated-solar/beams.png style=max-height:300px><figcaption>First working beam graphics</figcaption></figure><p>With power generation working, beams where quite simple to implement; a certain number of mirrors where identified as beam sources, and had a beam entity spawned between them and a point near the top of the tower (not exactly the top to add variation). This was calculated based on a simple hash of the <code>mid</code>, and beams were linked to mirrors so destruction was simple.<p>To make beams phase in over the day/night cycle, this process is repeated once every 600 ticks for all towers (incrementally, the same as the update routine above), and the hash was extended to allow a range of mirrors to produce beams, but lower hash numbers meant the beam was more prevalent throughout the day.<p>Beams are spawned with a lifetime of 600 ticks in the <code>generateBeam</code> method, to ensure they do not pile up and eventually crash the game<sup class=footnote-reference><a href=#1>2</a></sup>.<p>The core of the loop then, minus the incremental tower logic (effectively the same as the main loop code<sup class=footnote-reference><a href=#coremain>3</a></sup>):<pre class=language-lua data-lang=lua style=background-color:#272822;color:#f8f8f2;><code class=language-lua data-lang=lua><span style=color:#75715e;>-- Start spawning beams for the day
</span><span>
</span><span style=color:#f92672;>local </span><span>stage </span><span style=color:#f92672;>= </span><span style=color:#66d9ef;>math</span><span>.</span><span style=color:#66d9ef;>floor</span><span>(control_util.calc_sun(tower.surface) </span><span style=color:#f92672;>* </span><span>control_util.sun_stages) </span><span style=color:#f92672;>- </span><span style=color:#ae81ff;>1
</span><span>
</span><span style=color:#75715e;>-- max possible time a beam could live for, to account for possible errors
</span><span style=color:#f92672;>local </span><span>ttl </span><span style=color:#f92672;>= </span><span style=color:#66d9ef;>math</span><span>.</span><span style=color:#66d9ef;>abs</span><span>(tower.surface.evening </span><span style=color:#f92672;>- </span><span>tower.surface.dawn) </span><span style=color:#f92672;>* </span><span>tower.surface.ticks_per_day
</span><span>
</span><span style=color:#75715e;>--game.print("New sun stage " .. stage .. " with life of " .. ttl)
</span><span style=color:#f92672;>for </span><span>mid, mirror </span><span style=color:#f92672;>in </span><span style=color:#66d9ef;>pairs</span><span>(global.tower_mirrors[global.last_updated_tower_beam]) </span><span style=color:#f92672;>do
</span><span>    </span><span style=color:#75715e;>-- Can only spawn sun rays on mirrors with towers
</span><span>
</span><span>    </span><span style=color:#f92672;>local </span><span>group </span><span style=color:#f92672;>= </span><span>(mid </span><span style=color:#f92672;>* </span><span style=color:#ae81ff;>29</span><span>) </span><span style=color:#f92672;>% </span><span>control_util.mirror_groups
</span><span>
</span><span>    </span><span style=color:#f92672;>if </span><span>group </span><span style=color:#f92672;><= </span><span>stage </span><span style=color:#f92672;>and </span><span>global.mirror_tower[mid].beam </span><span style=color:#f92672;>== </span><span style=color:#ae81ff;>nil </span><span style=color:#f92672;>then
</span><span>        </span><span style=color:#75715e;>-- at this point, we don't need to worry about the old beams, as they have been destroyed
</span><span>        global.mirror_tower[mid].beam </span><span style=color:#f92672;>= </span><span>control_util.generateBeam
</span><span>            {
</span><span>                </span><span style=color:#e6db74;>mirror </span><span>= mirror,
</span><span>                </span><span style=color:#e6db74;>tower </span><span>= tower,
</span><span>                </span><span style=color:#e6db74;>ttl </span><span>= ttl
</span><span>            }
</span><span>    </span><span style=color:#f92672;>elseif </span><span>group </span><span style=color:#f92672;>> </span><span>stage </span><span style=color:#f92672;>and </span><span>global.mirror_tower[mid].beam </span><span style=color:#f92672;>then
</span><span>        global.mirror_tower[mid].beam.destroy()
</span><span>        global.mirror_tower[mid].beam </span><span style=color:#f92672;>= </span><span style=color:#ae81ff;>nil
</span><span>    </span><span style=color:#f92672;>end
</span><span style=color:#f92672;>end
</span><span>
</span></code></pre><p>The <code>mid</code> is multiplied by the prime 29 to give some randomness to beam placements, as entity indexes are assigned incrementally, so spawning based on just them clustered to beams<sup class=footnote-reference><a href=#2>4</a></sup>.<h3 id=overlay>Overlay</h3><figure><img alt=Overlay src=/projects/ch-concentrated-solar/overlay.png style=max-height:300px><figcaption>Early placement overlay</figcaption></figure><p>Turned out very easy to implement, as the game has very similar functionality for electrical systems - in the <code>defines.events.on_player_cursor_stack_changed</code> or <code>defines.events.on_selected_entity_changed</code>, check if the entity or stack in question is related to your system (in this case a tower or a mirror), and spawn bounding boxes for each important range-based entity (in this case, just towers).<hr><div class=footnote-definition id=rot><sup class=footnote-definition-label>1</sup><p>Another mod containing a feature with a similar mechanic of solar power used a separate entity for every mirror rotation, but I prefer turret prototype as it allows mirrors to be searched for quickly (different prototypes require unique names), and the number of rotation sprites can be changed in the future.</div><div class=footnote-definition id=1><sup class=footnote-definition-label>2</sup><p>This did happen.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>4</sup><p>An effect that I actually liked, but my tester<sup class=footnote-reference><a href=#3>5</a></sup> persuaded me against it.</div><div class=footnote-definition id=3><sup class=footnote-definition-label>5</sup><p>My brother.</div></article></div><footer class=footer><h2><a href=https://github.com/pettett>Github</a> | <a href=https://www.linkedin.com/in/maxwell-pettett/>LinkedIn</a> | maxwell pettett at gmail dot com | <a href=https://mastodon.gamedev.place/@pettett rel=me>Mastodon</a></h2></footer>